export *

import Server from "./libs/sockets-gr/server"
import Client from "./libs/sockets-gr/client"
import Array from "array"
import String from "string"
import Char from "char"
import Bytes from "bytes"
import Option from "option"
import Int32 from "int32"

let _MQTT_VERSION_3_1_1 = 4
let _MQTTBROKER_MY_NUM =  0
let _MQTTBROKER_MAX_NUM = 10

let _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX =       10
let _MQTTBROKER_MESSAGE_STACK_MAX =              5
let _MQTTBROKER_TOPIC_MAX_LENGTH =               64
let _MQTTBROKER_PAYLOAD_MAX_LENGTH =             255

// Packets
let _CONNECT = 1
let _CONNACK = 2
let _PUBLISH = 3
let _PUBACK = 4
let _PUBREC = 5 
let _PUBREL = 6
let _PUBCOMP = 7
let _SUBSCRIBE = 8
let _SUBACK = 9
let _UNSUBSCRIBE = 10
let _UNSUBACK = 11
let _PINGREQ = 12
let _PINGRESP = 13
let _DISCONNECT = 14

// Connect flags
let _CLEAN_SESSION = 0x02
let _WILL_FLAG = 0x04
let _WILL_QOS = 0x18
let _WILL_RETAIN = 0x20
let _PASSWORD_FLAG = 0x40
let _USER_NAME_FLAG = 0x80

// Sonnack sp
let _SESSION_PRESENT_ZERO = 0
let _SESSION_PRESENT_ONE = 1

// Connack rc
let _CONNECT_ACCEPTED = 0    
let _CONNECT_REFUSED_UPV = 1 
let _CONNECT_REFUSED_IR = 2  
let _CONNECT_REFUSED_SU = 3  
let _CONNECT_REFUSED_BUP = 4 
let _CONNECT_REFUSED_NA = 5  

let debug = (text) => {
    if (1 == 0) {
        print(text)
    }
}
record MqttSubscription {
    mut status: Bool,
    mut topicName: String,
    mut topicLength: Number
}

record MqttClient {
    mut state: Bool,
    mut socketClient: Option<Client.Client>,
    subscriptions: Array<MqttSubscription>
}

record MqttBroker {
    initialize: () -> Void,
    start: () -> Void,
    loop: () -> Void,
    connect: (Number) -> Void,
    subscribe: (String) -> Void,
    unsubscribe: (String) ->Void,
    publish: (String, Bytes, Number, Bool) -> Void,
    onReceive: ((MqttClient, String, String) -> Void) -> Void,
}


let new = () => {
    let mut callbackEnabled = false
    let socketServer = Server.new(0, 10)
    let mqttClients = Array.make(10, {
                state: false, 
                socketClient: None,
                subscriptions: Array.make(_MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX, {
                    status: false, 
                    topicName: "", 
                    topicLength: 0
                } : MqttSubscription)
            } : MqttClient)

    let mut cbReceive = (cb: client: MqttClient,topic: String, message: String) => {void}

    let msbLsb = (byte) => {
        (byte <<8) + (byte+1)
    }

    let compare = (topic: String, subscription: MqttSubscription) => {
        let mut cs = 0
        let mut ct = 0
        let mut result = false
        let length = String.length(topic)

        for (ct = 0; ct < length; ct += 1) {

            if (cs >= subscription.topicLength) {
                result = false
                break
            } 
            if (String.charAt(ct, topic) == String.charAt(cs, subscription.topicName)) {
                cs += 1
            } else {
                if (String.charAt(cs, subscription.topicName) == Char.fromCode(0x2B)) {
                    if ((String.charAt(ct, topic) == Char.fromCode(0x2F)) && (cs < subscription.topicLength - 1) && (String.charAt(cs+1, subscription.topicName) == Char.fromCode(0x2F))) {
                            cs += 2
                        }
                } else if (String.charAt(cs, subscription.topicName) == Char.fromCode(0x23)) {
                    result = true
                    break
                } else {
                    result = false
                    break
                }
            }
        }

        if (!result) {
            if ((String.charAt(cs,subscription.topicName) == Char.fromCode(0x2B)) && (cs == subscription.topicLength -1)) {
                result = true
            }
            else if (cs < subscription.topicLength) {
                result = false
            } 
            else if (cs == subscription.topicLength) {
                result = true
            } else {
                result= false
            }
        }

        result
    }

    let subscribeInternal = (num: Number, topic: String, length: Number) => {
        let mut result = false;
        let mut clear = _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX

        if (length < _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX) {

            for (let mut i = 0; i < _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX; i += 1) {
                if (!mqttClients[num].subscriptions[i].status) {
                    if (clear == _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX) {
                        clear = i
                    } else {
                        if (mqttClients[num].subscriptions[i].topicName == topic) {
                            result = true
                            break
                        }
                    }
                }
            }
        }

        if (clear != _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX) {
            mqttClients[num].subscriptions[clear].status = true
            mqttClients[num].subscriptions[clear].topicName = topic
            mqttClients[num].subscriptions[clear].topicLength = length

            result = true 
        } else {
            result = false;
        }
        result
    }   

    let unsubscribe = (num: Number, topic: Option<String>, length: Number) => {
        let i = 0
        match (topic) {
            Some(s) =>  {
                for (let mut i = 0; i < _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX; i = incr(1)) {
                    if (s == mqttClients[num].subscriptions[i].topicName)
                        mqttClients[num].subscriptions[i].status = false
                }
            },
            None => {
                for (let mut i = 0; i <  _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX; i = incr(i)) {
                    mqttClients[num].subscriptions[i].status = false
                }
            }
        }
        void
    }
    
    let numIsIncorrect = (num: Number) => {
        if (num >= _MQTTBROKER_MAX_NUM) {
            true
        } else {
            false
        }
    }

    let clientIsConnected = (num: Number) => {
        if (num == _MQTTBROKER_MY_NUM) {
            true
        } else if (numIsIncorrect(num)) {
            false
        } else {
            mqttClients[num].state
        }
    }


    let _connect = (num: Number) => {
        mqttClients[num].state = true
    }

    let _disconnect = (num: Number) => {
        if (!numIsIncorrect(num)) {
            unsubscribe(num, None, 0)
            mqttClients[num].state = false
            socketServer.disconnectClient(Option.unwrap(mqttClients[num].socketClient))
        }
    }

    let _subscribe = (topic: String) => {
        subscribeInternal(_MQTTBROKER_MY_NUM, topic, String.length(topic))
        void
    }

    let _unsubscribe = (topic: String) => {
        unsubscribe(_MQTTBROKER_MY_NUM, Some(topic), String.length(topic))
    }


    let sendAnswer = (num: Number, fixedHeader: Number, fixedHeaderLsb: Number, fixedHeaderRemaining: Number, variableHeader: Bytes, variableHeaderLength: Number, payload: Option<Bytes>, payloadLength: Option<Number>) => {
        let mut return = false
        let mut ii = 0

        let answer = Bytes.make(fixedHeaderRemaining +2)

        Bytes.setInt8(0, Int32.fromNumber(((fixedHeader << 4) | fixedHeaderLsb)), answer)
        Bytes.setInt8(1, Int32.fromNumber(fixedHeaderRemaining), answer)

        for (let mut i = 2; i < variableHeaderLength + 2; i+=1) {
            Bytes.setInt8(i, Bytes.getInt8U(i-2, variableHeader) ,answer)
            ii = i
        }

        match (fixedHeader) {
            _ when fixedHeader == _CONNACK => debug("[MQTT]["++toString(i)++"][SEND] CONNACK"),
            _ when fixedHeader == _SUBACK => {
                for (let mut i = 0; i < Option.unwrap(payloadLength); i += 1) {
                    Bytes.setInt8(i, Bytes.getInt8U(i,  Option.unwrap(payload)) ,answer)
                }
                debug("[MQTT]["++toString(i)++"][SEND] SUBACK")
                void
            },
            _ when fixedHeader == _UNSUBACK => debug("[MQTT]["++toString(i)++"][SEND] UNSUBACK"),
            _ when fixedHeader == _PINGRESP => debug("[MQTT]["++toString(i)++"][SEND] PINGRESP"),
            _ => {
                return = true
            }
        }
        
        if (!return) {
            
            // TODO Send binary: answer_msg, fixedHeaderRemaining +2
            socketServer.sendBytes(Option.unwrap(mqttClients[num].socketClient),  answer, Bytes.length(answer) )
            void
        }
        void
    }

    let sendMessage = (num: Number, topic: Bytes, payload: Bytes) => {
        let remainingLength = Bytes.length(topic) + Bytes.length(payload) + 4
        let topicLength = Bytes.length(topic)

        let answer = Bytes.make(remainingLength)

        Bytes.setInt8(0, Int32.fromNumber((_PUBLISH << 4) | 0x00), answer)
        Bytes.setInt8(1, Int32.fromNumber(remainingLength), answer)
        Bytes.setInt8(2, 0l, answer)
        Bytes.setInt8(3, Int32.fromNumber(topicLength), answer)

        for (let mut i = 4; i < topicLength+4; i += 1) {
            Bytes.setInt8(i, Bytes.getInt8U(i-4, topic), answer)
        }

        for (let mut i = topicLength + 4; i < remainingLength  ; i += 1) {
            Bytes.setInt8(i, Bytes.getInt8U(i - topicLength - 4, payload), answer)
        }
        
        socketServer.sendBytes(Option.unwrap(mqttClients[num].socketClient),  answer, Bytes.length(answer))
        void
    }
    
    let publishToClient = (num: Number, topic: Bytes, payload: Bytes, retain: Number) => {
        if (Bytes.length(topic) <= _MQTTBROKER_TOPIC_MAX_LENGTH) {
            let topicStr = Bytes.toString(topic)

            for (let mut i = 0; i < _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX; i += 1) {
                if (i == num) {
                    continue
                } else {
                    if (clientIsConnected(i)) {
                        for (let mut j = 0; j < _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX; j += 1) {
                            if (mqttClients[i].subscriptions[j].status) {
                                if (compare(topicStr, mqttClients[i].subscriptions[j])) {
                                    if (i == _MQTTBROKER_MY_NUM) {
                                        callbackEnabled  = true
                                    } else {
                                        sendMessage(i, topic, payload)
                                    }
                                }
                            }
                        }
                    }
                }
            }

            true
            // TODO: retain
        } else {
            debug("[PUBLISH] Topic length to long!")
            false
        }
        false
    }

    let parsing = (num: Number, payload: String, length: Number) => {
        if (!numIsIncorrect(num)) {
            let b = Bytes.fromString(payload)
            let k = Int32.toNumber(Bytes.getInt8U(0, b)) >> 4

            match (k) {
                _ when k == _CONNECT  => {
                    let variableHeader = Bytes.make(2);
                    let protocolLevel = String.charCodeAt(8,payload);
                    let connectFlags = String.charCodeAt(9,payload);
                    
                    debug("[CONNECT] " ++ toString(protocolLevel) ++ " - " ++ toString(connectFlags))

                    Bytes.setInt8(0, Int32.fromNumber(0x01 & _SESSION_PRESENT_ZERO), variableHeader)

                    if (protocolLevel == _MQTT_VERSION_3_1_1) {
                        Bytes.setInt8(1, Int32.fromNumber( _CONNECT_ACCEPTED), variableHeader)
                        sendAnswer(num, _CONNACK, 0, 2, variableHeader, 2, None, None)
                        _connect(num)
                    } else {
                        Bytes.setInt8(1, Int32.fromNumber( _CONNECT_REFUSED_UPV), variableHeader)
                        sendAnswer(num, _CONNACK, 0, 2, variableHeader, 2, None, None)
                        _disconnect(num)
                    }

                },
                _ when k == _PUBLISH => {
                    let z = Int32.toNumber(Bytes.getInt8U(0, b)) 
                    let dup = (z >> 3) & 0x1 // TODO
                    let qos = (z >> 1) & 0x3 // TODO
                    let retain = z & 0x1

                    let remainingLength = Int32.toNumber(Bytes.getInt8U(1,b))
                    let mut lengthTopic = Int32.toNumber( Bytes.getInt8S(3,b))

                    let topic = Bytes.toString(Bytes.slice(4,Bytes.length(b) - remainingLength, b))

                    if (lengthTopic > 255) {
                        lengthTopic = _MQTTBROKER_TOPIC_MAX_LENGTH
                    }

                    let mut packetIdentifier = Bytes.make(0)

                    if (qos > 0) {
                        packetIdentifier = Bytes.make(1)
                        Bytes.setInt8(0,Bytes.getInt8U(4+lengthTopic,b), packetIdentifier)
                    }


                    let p = Bytes.slice(4,lengthTopic, b)
                    let m = Bytes.slice(4+Bytes.length(packetIdentifier) + lengthTopic, Bytes.length(b)- (4+Bytes.length(packetIdentifier) + lengthTopic), b)

                    debug("[PUBLISH]["++ toString(num) ++"][DUP "++ toString(dup) ++"][QOS "++ toString(qos) ++"][RETAIN "++ toString(retain) ++"][Topic "++Bytes.toString(p)++"]")

                    publishToClient(num, p,m, retain  )    

                    match (qos) {
                        _ when qos == 0 => {void},
                        _ when qos == 1 => sendAnswer(num, _PUBACK,0,2, Bytes.make(0), 0, None, None),
                        _ when qos == 2 => {
                            sendAnswer(num, _PUBREC,0,2, Bytes.make(0), 0, None, None);
                            sendAnswer(num, _PUBREL,0,2, Bytes.make(0), 0, None, None);
                            sendAnswer(num, _PUBCOMP,0,2, Bytes.make(0), 0, None, None);
                        },
                        _ => void
                    }

                    if (callbackEnabled) {
                        cbReceive(mqttClients[num],Bytes.toString(p),Bytes.toString(m))
                        callbackEnabled = false
                    }

                    void
                },
                _ when k == _SUBSCRIBE => {
                    let packetIdentifier = msbLsb(Int32.toNumber( Bytes.getInt8U(2,b)))          
                    let lengthMsbLsb = msbLsb(Int32.toNumber( Bytes.getInt8U(4,b)))          
                    let requestedQos = Bytes.slice(6 + lengthMsbLsb,1,b)
                    let topic = Bytes.toString(Bytes.slice(6,Bytes.length(b) - 6, b))

                    debug("[SUBSCRIBE]["++ toString(num) ++"][Paket: "++ toString(packetIdentifier) ++ "][Length: "++ toString(lengthMsbLsb) ++"][Qos: "++ Bytes.toString(requestedQos) ++"][Topic: "++ topic++ "]")
                    subscribeInternal(num, topic, String.length(topic))
                    
                    let result = Bytes.slice(2,2, b)
                    sendAnswer(num, _SUBACK, 0, 3, result, Bytes.length(result), Some(requestedQos), Some(1))  
                    void
                },
                _ when k == _UNSUBSCRIBE => {
                    let packetIdentifier = msbLsb(Int32.toNumber( Bytes.getInt8U(2,b)))          
                    let lengthMsbLsb = msbLsb(Int32.toNumber( Bytes.getInt8U(4,b)))          
                    let topic = Bytes.toString(Bytes.slice(6,Bytes.length(b) - 6, b))
                    let result = Bytes.slice(2,2,b)

                    debug("[UNSUBSCRIBE]["++ toString(num) ++"][Paket: "++ toString(packetIdentifier) ++ "][Length: "++ toString(lengthMsbLsb) ++"][Topic: "++ topic++ "]")
                    sendAnswer(num, _UNSUBACK, 0, 2, result, Bytes.length(result), None, None);
                    void
                },
                _ when k == _PINGREQ => {
                    debug("[PINGREQ]["++ toString(num) ++"]")
                    sendAnswer(num, _PINGRESP,0,2, Bytes.make(0), 0, None, None);
                    void    
                },
                _ when k == _DISCONNECT => {
                    debug("[DISCONNECT]["++ toString(num) ++"]")
                    _disconnect(num);
                    void
                },
                _ => debug("[UNKNOWN]")
            }
        }
        void
    }
 
    let _initialize = () => {

        for (let mut i = 0; i < 5; i = incr(i)) {
            mqttClients[i].state = false;
            for (let mut j = 0; j < _MQTTBROKER_CLIENT_SUBSCRIPTIONS_MAX; j = incr(j)) {
                mqttClients[i].subscriptions[j].status = false
            }
        }

        socketServer.onConnected(
            (client) => {
                print("Client connected")
                mqttClients[client.getFileDescriptorNumber()].socketClient = Some(client)
                void
            }
        )


        socketServer.onDisconnected(
            (client) => {
                print("Client disconnected")
                void
            }
        )

        socketServer.onReceive(
            (client, message) => {
                parsing(client.getFileDescriptorNumber(), message, String.length(message))
                void
            }
        )
        void
    }

    let _start = () => {
        socketServer.start()
        void
    }

    let _loop = () => {
        socketServer.accecptClient();
        void
    }

    let _setReceiveCallback = (cb: ((MqttClient, String, String) -> Void)) => {
        cbReceive = cb
    }

    
    let _publish = (topic: String, payload: Bytes, length: Number, retain: Bool) => {
        void
    }

    // return
    {
        initialize: _initialize,
        start: _start,
        loop: _loop,
        connect: _connect,
        subscribe: _subscribe,
        unsubscribe: _unsubscribe,
        publish: _publish,
        onReceive: _setReceiveCallback,
    }
}
